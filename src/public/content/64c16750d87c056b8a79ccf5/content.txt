{"ops":[{"insert":"What's new in .NET 8"},{"attributes":{"header":1},"insert":"\n"},{"insert":"Article07/15/2023"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"7 contributors"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Feedback\nIn this article"},{"attributes":{"header":2},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#serialization"},"insert":"Serialization"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#core-net-libraries"},"insert":"Core .NET libraries"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#extension-libraries"},"insert":"Extension libraries"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#garbage-collection"},"insert":"Garbage collection"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Show 11 more\n.NET 8 is the successor to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-7"},"insert":".NET 7"},{"insert":". It will be "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://dotnet.microsoft.com/platform/support/policy/dotnet-core"},"insert":"supported for three years"},{"insert":" as a long-term support (LTS) release. You can "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://dotnet.microsoft.com/download/dotnet"},"insert":"download .NET 8 here"},{"insert":".\nThis article has been updated for .NET 8 Preview 6.\n Important\n\nThis information relates to a pre-release product that may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Much of the other .NET documentation on "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-primary-dark)","link":"https://learn.microsoft.com/en-us/dotnet"},"insert":"https://learn.microsoft.com/dotnet"},{"insert":" has not yet been updated for .NET 8."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Serialization"},{"attributes":{"header":2},"insert":"\n"},{"insert":"Many improvements have been made to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json"},"insert":"System.Text.Json"},{"insert":" serialization and deserialization functionality including:\nYou can "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/missing-members"},"insert":"customize handling of members that aren't in the JSON payload."},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.makereadonly#system-text-json-jsonserializeroptions-makereadonly"},"insert":"JsonSerializerOptions.MakeReadOnly()"},{"insert":" gives you explicit control over when a "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonSerializerOptions"},{"insert":" instance is frozen. (You can also check it with the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.isreadonly#system-text-json-jsonserializeroptions-isreadonly"},"insert":"IsReadOnly"},{"insert":" property.)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.addcontext#system-text-json-jsonserializeroptions-addcontext-1"},"insert":"JsonSerializerOptions.AddContext<TContext>()"},{"insert":" is now obsolete. It's been superseded by the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolver#system-text-json-jsonserializeroptions-typeinforesolver"},"insert":"TypeInfoResolver"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain#system-text-json-jsonserializeroptions-typeinforesolverchain"},"insert":"TypeInfoResolverChain"},{"insert":" properties. For more information, see "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#chain-source-generators"},"insert":"Chain source generators"},{"insert":"."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"The new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.trygettypeinfo#system-text-json-jsonserializeroptions-trygettypeinfo(system-type-system-text-json-serialization-metadata-jsontypeinfo@)"},"insert":"TryGetTypeInfo(Type, JsonTypeInfo)"},{"insert":" method, a variation of the existing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.gettypeinfo#system-text-json-jsonserializeroptions-gettypeinfo(system-type)"},"insert":"GetTypeInfo(Type)"},{"insert":" method, returns "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"false"},{"insert":" if no metadata for the specified type was found."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Support for compiler-generated or "},{"attributes":{"italic":true},"insert":"unspeakable"},{"insert":" types in weakly typed source generation scenarios. Since compiler-generated types can't be explicitly specified by the source generator, "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json"},"insert":"System.Text.Json"},{"insert":" now performs nearest-ancestor resolution at run time. This resolution determines the most appropriate supertype with which to serialize the value."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"The following sections go into more depth about other serialization improvements:\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#source-generator"},"insert":"Source generator"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#interface-hierarchies"},"insert":"Interface hierarchies"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#naming-policies"},"insert":"Naming policies"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#read-only-properties"},"insert":"Read-only properties"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#disable-reflection-based-default"},"insert":"Disable reflection-based default"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"For more information about JSON serialization in general, see "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview"},"insert":"JSON serialization and deserialization in .NET"},{"insert":".\nSource generator"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n.NET 8 includes performance and reliability enhancements of the System.Text.Json "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation"},"insert":"source generator"},{"insert":" that are aimed at making the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/glossary#native-aot"},"insert":"native AOT"},{"insert":" experience on par with the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation-modes#overview"},"insert":"reflection-based serializer"},{"insert":". For example:\nThe "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation"},"insert":"source generator"},{"insert":" now supports serializing types with "},{"attributes":{"link":"https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/required-properties","background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","code":true},"insert":"required"},{"insert":" and "},{"attributes":{"link":"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/init","background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","code":true},"insert":"init"},{"insert":" properties. These were both already supported in reflection-based serialization."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"Improved formatting of source-generated code."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"Additional diagnostics (such as "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SYSLIB1034"},{"insert":" and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SYSLIB1039"},{"insert":")."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"Don't include types of ignored or inaccessible properties."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"Support for nesting "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonSerializerContext"},{"insert":" declarations within arbitrary type kinds."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"New converter type "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonStringEnumConverter<TEnum>"},{"insert":". The existing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter"},"insert":"JsonStringEnumConverter"},{"insert":" class isn't supported in native AOT. You can annotate your enum types as follows:"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"C#"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Copy"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"[JsonConverter(typeof(JsonStringEnumConverter<MyEnum>))]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"public enum MyEnum { Value1, Value2, Value3 }"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"[JsonSerializable(typeof(MyEnum))]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"public partial class MyContext : JsonSerializerContext { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"New "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonConverter.Type"},{"insert":" property lets you look up the type of a non-generic `JsonConverter`` instance:"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"C#"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Copy"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Dictionary<Type, JsonConverter> CreateDictionary(IEnumerable<JsonConverter> converters)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  => converters.Where(converter => converter.Type != null).ToDictionary(converter => converter.Type!);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"The property is nullable since it returns "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"null"},{"insert":" for "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonConverterFactory"},{"insert":" instances and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"typeof(T)"},{"insert":" for "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonConverter<T>"},{"insert":" instances."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Chain source generators"},{"attributes":{"header":4},"insert":"\n"},{"insert":"\nThe "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions"},"insert":"JsonSerializerOptions"},{"insert":" class includes a new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain#system-text-json-jsonserializeroptions-typeinforesolverchain"},"insert":"TypeInfoResolverChain"},{"insert":" property that complements the existing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolver#system-text-json-jsonserializeroptions-typeinforesolver"},"insert":"TypeInfoResolver"},{"insert":" property. These properties are used in contract customization for chaining source generators. The addition of the new property means that you don't have to specify all chained components at one call site—they can be added after the fact.\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain#system-text-json-jsonserializeroptions-typeinforesolverchain"},"insert":"TypeInfoResolverChain"},{"insert":" also lets you introspect the chain or remove components from it. The following code snippet shows an example.\nC#\nCopy\nvar options = new JsonSerializerOptions"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    TypeInfoResolver = JsonTypeInfoResolver.Combine("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        ContextA.Default, ContextB.Default, ContextC.Default);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"options.TypeInfoResolverChain.Count; // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"options.TypeInfoResolverChain.RemoveAt(0);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"options.TypeInfoResolverChain.Count; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Interface hierarchies"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n.NET 8 adds support for serializing properties from interface hierarchies.\nThe following code shows an example where the properties from both the immediately implemented interface and its base interface are serialized.\nC#\nCopy\nIDerived value = new DerivedImplement { Base = 0, Derived = 1 };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"JsonSerializer.Serialize(value); // {\"Base\":0,\"Derived\":1}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"public interface IBase"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public int Base { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"public interface IDerived : IBase"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public int Derived { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"public class DerivedImplement : IDerived"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public int Base { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public int Derived { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Naming policies"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n"},{"attributes":{"link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonnamingpolicy?view=net-8.0&preserve-view=true#properties","background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","code":true},"insert":"JsonNamingPolicy"},{"insert":" includes new naming policies for "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"snake_case"},{"insert":" (with an underscore) and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"kebab-case"},{"insert":" (with a hyphen) property name conversions. Use these policies similarly to the existing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonnamingpolicy.camelcase#system-text-json-jsonnamingpolicy-camelcase"},"insert":"JsonNamingPolicy.CamelCase"},{"insert":" policy:\nC#\nCopy\nvar options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"JsonSerializer.Serialize(new { PropertyName = \"value\" }, options); // { \"property_name\" : \"value\" }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Read-only properties"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nYou can now deserialize onto read-only fields or properties (that is, those that don't have a "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"set"},{"insert":" accessor).\nTo opt into this support globally, set a new option, "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.preferredobjectcreationhandling#system-text-json-jsonserializeroptions-preferredobjectcreationhandling"},"insert":"PreferredObjectCreationHandling"},{"insert":", to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonobjectcreationhandling#system-text-json-serialization-jsonobjectcreationhandling-populate"},"insert":"JsonObjectCreationHandling.Populate"},{"insert":". If compatibility is a concern, you can also enable the functionality more granularly by placing the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"[JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]"},{"insert":" attribute on types whose properties are to be populated, or on individual properties.\nFor example, consider the following code that deserializes into a "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"CustomerInfo"},{"insert":" type that has two read-only properties.\nC#\nCopy\nusing System.Text.Json;"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"CustomerInfo customer ="},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    JsonSerializer.Deserialize<CustomerInfo>(\"\"\"{\"Name\":\"John Doe\",\"Company\":{\"Name\":\"Contoso\"}}\"\"\")!;"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"Console.WriteLine(JsonSerializer.Serialize(customer));"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"class CompanyInfo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public required string Name { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public string? PhoneNumber { get; set; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"[JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"class CustomerInfo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // Both of these properties are read-only."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public string Name { get; } = \"Anonymous\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public CompanyInfo Company { get; } = new() { Name = \"N/A\", PhoneNumber = \"N/A\" };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Prior to .NET 8, the input values were ignored and the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Name"},{"insert":" and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Company"},{"insert":" properties retained their default values.\nOutput\nCopy\n{\"Name\":\"Anonymous\",\"Company\":{\"Name\":\"N/A\",\"PhoneNumber\":\"N/A\"}}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Now, the input values are used to populate the read-only properties during deserialization.\nOutput\nCopy\n{\"Name\":\"John Doe\",\"Company\":{\"Name\":\"Contoso\",\"PhoneNumber\":null}}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nDisable reflection-based default"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nYou can now disable using the reflection-based serializer by default. This disablement is useful to avoid accidental rooting of reflection components that aren't even in use, especially in trimmed and native AOT apps. To disable default reflection-based serialization by requiring that a "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions"},"insert":"JsonSerializerOptions"},{"insert":" argument be passed to the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer"},"insert":"JsonSerializer"},{"insert":" serialization and deserialization methods, set the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"JsonSerializer.IsReflectionEnabledByDefault"},{"insert":" property to "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"false"},{"insert":" in your project file. (If the property is set to "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"false"},{"insert":" and you don't pass a configured "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions"},"insert":"JsonSerializerOptions"},{"insert":" argument, the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Serialize"},{"insert":" and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Deserialize"},{"insert":" methods throw a "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.notsupportedexception"},"insert":"NotSupportedException"},{"insert":" at run time.)\nUse the new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer.isreflectionenabledbydefault#system-text-json-jsonserializer-isreflectionenabledbydefault"},"insert":"IsReflectionEnabledByDefault"},{"insert":" property to check the value of the feature switch. If you're a library author building on top of "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.json"},"insert":"System.Text.Json"},{"insert":", you can rely on the property to configure your defaults without accidentally rooting reflection components.\nC#\nCopy\nstatic JsonSerializerOptions GetDefaultOptions()"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    if (JsonSerializer.IsReflectionEnabledByDefault)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        // This branch has a dependency on DefaultJsonTypeInfo,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        // but it will get trimmed away if the feature switch is disabled."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return new()"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            TypeInfoResolver = new DefaultJsonTypeInfoResolver(),"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            PropertyNamingPolicy = JsonNamingPolicy.KebabCaseLower,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"    return new() { PropertyNamingPolicy = JsonNamingPolicy.KebabCaseLower };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Core .NET libraries"},{"attributes":{"header":2},"insert":"\n"},{"insert":"This section contains the following subtopics:\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#time-abstraction"},"insert":"Time abstraction"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#utf8-improvements"},"insert":"UTF8 improvements"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#methods-for-working-with-randomness"},"insert":"Methods for working with randomness"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#performance-focused-types"},"insert":"Performance-focused types"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#systemnumerics-and-systemruntimeintrinsics"},"insert":"System.Numerics and System.Runtime.Intrinsics"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#data-validation"},"insert":"Data validation"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#metrics"},"insert":"Metrics"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#cryptography"},"insert":"Cryptography"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#stream-based-zipfile-methods"},"insert":"Stream-based ZipFile methods"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Time abstraction"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nThe new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider"},"insert":"TimeProvider"},{"insert":" class and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.itimer"},"insert":"ITimer"},{"insert":" interface add "},{"attributes":{"italic":true},"insert":"time abstraction"},{"insert":" functionality, which allows you to mock time in test scenarios. In addition, you can use the time abstraction to mock "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task"},"insert":"Task"},{"insert":" operations that rely on time progression using "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.delay"},"insert":"Task.Delay"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync"},"insert":"Task.WaitAsync"},{"insert":". The time abstraction supports the following essential time operations:\nRetrieve local and UTC time"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Obtain a timestamp for measuring performance"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Create a timer"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"The following code snippet shows some usage examples.\nC#\nCopy\n// Get system time."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"DateTimeOffset utcNow = TimeProvider.System.GetUtcNow();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"DateTimeOffset localNow = TimeProvider.System.GetLocalNow();"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// Create a time provider that works with a"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// time zone that's different than the local time zone."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"private class ZonedTimeProvider : TimeProvider"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    private TimeZoneInfo _zoneInfo;"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"    public ZonedTimeProvider(TimeZoneInfo zoneInfo) : base()"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        _zoneInfo = zoneInfo ?? TimeZoneInfo.Local;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"    public override TimeZoneInfo LocalTimeZone => _zoneInfo;"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"    public static TimeProvider FromLocalTimeZone(TimeZoneInfo zoneInfo) =>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        new ZonedTimeProvider(zoneInfo);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// Create a timer using a time provider."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"ITimer timer = timeProvider.CreateTimer(callBack, state, delay, Timeout.InfiniteTimeSpan);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// Measure a period using the system time provider."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"long providerTimestamp1 = TimeProvider.System.GetTimestamp();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"long providerTimestamp2 = TimeProvider.System.GetTimestamp();"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"var period = GetElapsedTime(providerTimestamp1, providerTimestamp2);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"UTF8 improvements"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nIf you want to enable writing out a string-like representation of your type to a destination span, implement the new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanformattable"},"insert":"IUtf8SpanFormattable"},{"insert":" interface on your type. This new interface is closely related to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.ispanformattable"},"insert":"ISpanFormattable"},{"insert":", but targets UTF8 and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Span<byte>"},{"insert":" instead of UTF16 and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Span<char>"},{"insert":".\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanformattable"},"insert":"IUtf8SpanFormattable"},{"insert":" has been implemented on all of the primitive types (plus others), with the exact same shared logic whether targeting "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"string"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Span<char>"},{"insert":", or "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Span<byte>"},{"insert":". It has full support for all formats (including the new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings#binary-format-specifier-b"},"insert":"\"B\" binary specifier"},{"insert":") and all cultures. This means you can now format directly to UTF8 from "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Byte"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Complex"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Char"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"DateOnly"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"DateTime"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"DateTimeOffset"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Decimal"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Double"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Guid"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Half"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"IPAddress"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"IPNetwork"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Int16"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Int32"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Int64"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Int128"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"IntPtr"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"NFloat"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SByte"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Single"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Rune"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"TimeOnly"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"TimeSpan"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"UInt16"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"UInt32"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"UInt64"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"UInt128"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"UIntPtr"},{"insert":", and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Version"},{"insert":".\nNew "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.unicode.utf8.trywrite"},"insert":"Utf8.TryWrite"},{"insert":" methods provide a UTF8-based counterpart to the existing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.trywrite"},"insert":"MemoryExtensions.TryWrite"},{"insert":" methods, which are UTF16-based. You can use interpolated string syntax to format a complex expression directly into a span of UTF8 bytes, for example:\nC#\nCopy\nstatic bool FormatHexVersion("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    short major,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    short minor,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    short build,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    short revision,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Span<byte> utf8Bytes,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    out int bytesWritten) =>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Utf8.TryWrite("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        utf8Bytes,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        CultureInfo.InvariantCulture,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        $\"{major:X4}.{minor:X4}.{build:X4}.{revision:X4}\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        out bytesWritten);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"The implementation recognizes "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanformattable"},"insert":"IUtf8SpanFormattable"},{"insert":" on the format values and uses their implementations to write their UTF8 representations directly to the destination span.\nThe implementation also utilizes the new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.trygetbytes#system-text-encoding-trygetbytes(system-readonlyspan((system-char))-system-span((system-byte))-system-int32@)"},"insert":"Encoding.TryGetBytes(ReadOnlySpan<Char>, Span<Byte>, Int32)"},{"insert":" method, which together with its "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding.trygetchars#system-text-encoding-trygetchars(system-readonlyspan((system-byte))-system-span((system-char))-system-int32@)"},"insert":"Encoding.TryGetChars(ReadOnlySpan<Byte>, Span<Char>, Int32)"},{"insert":" counterpart, supports encoding and decoding into a destination span. If the span isn't long enough to hold the resulting state, the methods return "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"false"},{"insert":" rather than throwing an exception.\nMethods for working with randomness"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nThe "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.random"},"insert":"System.Random"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator"},"insert":"System.Security.Cryptography.RandomNumberGenerator"},{"insert":" types introduce two new methods for working with randomness.\n\nGetItems<T>()"},{"attributes":{"header":4},"insert":"\n"},{"insert":"\nThe new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.random.getitems"},"insert":"System.Random.GetItems"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator.getitems"},"insert":"System.Security.Cryptography.RandomNumberGenerator.GetItems"},{"insert":" methods let you randomly choose a specified number of items from an input set. The following example shows how to use "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"System.Random.GetItems<T>()"},{"insert":" (on the instance provided by the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.random.shared#system-random-shared"},"insert":"Random.Shared"},{"insert":" property) to randomly insert 31 items into an array. This example could be used in a game of \"Simon\" where players must remember a sequence of colored buttons.\nC#\nCopy\nprivate static ReadOnlySpan<Button> s_allButtons = new[]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Button.Red,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Button.Green,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Button.Blue,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Button.Yellow,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// ..."},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"Button[] thisRound = Random.Shared.GetItems(s_allButtons, 31);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Rest of game goes here ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Shuffle<T>()"},{"attributes":{"header":4},"insert":"\n"},{"insert":"\nThe new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.random.shuffle"},"insert":"Random.Shuffle"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator.shuffle#system-security-cryptography-randomnumbergenerator-shuffle-1(system-span((-0)))"},"insert":"RandomNumberGenerator.Shuffle<T>(Span<T>)"},{"insert":" methods let you randomize the order of a span. These methods are useful for reducing training bias in machine learning (so the first thing isn't always training, and the last thing always test).\nC#\nCopy\nYourType[] trainingData = LoadTrainingData();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Random.Shared.Shuffle(trainingData);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"IDataView sourceData = mlContext.Data.LoadFromEnumerable(trainingData);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"DataOperationsCatalog.TrainTestData split = mlContext.Data.TrainTestSplit(sourceData);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"model = chain.Fit(split.TrainSet);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"IDataView predictions = model.Transform(split.TestSet);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Performance-focused types"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n.NET 8 introduces several new types aimed at improving app performance.\nThe new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen"},"insert":"System.Collections.Frozen"},{"insert":" namespace includes the collection types "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen.frozendictionary-2"},"insert":"FrozenDictionary<TKey,TValue>"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.collections.frozen.frozenset-1"},"insert":"FrozenSet<T>"},{"insert":". These types don't allow any changes to keys and values once a collection created. That requirement allows faster read operations (for example, "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"TryGetValue()"},{"insert":"). These types are particularly useful for collections that are populated on first use and then persisted for the duration of a long-lived service, for example:"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"C#"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Copy"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"private static readonly FrozenDictionary<string, bool> s_configurationData ="},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    LoadConfigurationData().ToFrozenDictionary(optimizeForReads: true);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (s_configurationData.TryGetValue(key, out bool setting) && setting)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Process();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"The new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.buffers.searchvalues-1"},"insert":"System.Buffers.SearchValues<T>"},{"insert":" type is designed to be passed to methods that look for the first occurrence of any value in the passed collection. For example, "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.string.indexofany#system-string-indexofany(system-char())"},"insert":"String.IndexOfAny(Char[])"},{"insert":" looks for the first occurrence of any character in the specified array in the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"string"},{"insert":" it's called on. NET 8 adds new overloads of methods like "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.string.indexofany"},"insert":"String.IndexOfAny"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexofany"},"insert":"MemoryExtensions.IndexOfAny"},{"insert":" that accept an instance of the new type. When you create an instance of "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.buffers.searchvalues-1"},"insert":"System.Buffers.SearchValues<T>"},{"insert":", all the data that's necessary to optimize subsequent searches is derived "},{"attributes":{"italic":true},"insert":"at that time"},{"insert":", meaning the work is done up front."},{"attributes":{"list":"bullet"},"insert":"\n\n"},{"insert":"The new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.text.compositeformat"},"insert":"System.Text.CompositeFormat"},{"insert":" type is useful for optimizing format strings that aren't known at compile time (for example, if the format string is loaded from a resource file). A little extra time is spent up front to do work such as parsing the string, but it saves the work from being done on each use."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"C#"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Copy"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"private static readonly CompositeFormat s_rangeMessage ="},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    CompositeFormat.Parse(LoadRangeMessageResource());"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"static string GetMessage(int min, int max) =>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    string.Format(CultureInfo.InvariantCulture, s_rangeMessage, min, max);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"New "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.io.hashing.xxhash3"},"insert":"System.IO.Hashing.XxHash3"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.io.hashing.xxhash128"},"insert":"System.IO.Hashing.XxHash128"},{"insert":" types provide implementations of the fast XXH3 and XXH128 hash algorithms."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"System.Numerics and System.Runtime.Intrinsics"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nThis section covers improvements to the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.numerics"},"insert":"System.Numerics"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics"},"insert":"System.Runtime.Intrinsics"},{"insert":" namespaces.\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256-1"},"insert":"Vector256<T>"},{"insert":", "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.numerics.matrix3x2"},"insert":"Matrix3x2"},{"insert":", and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.numerics.matrix4x4"},"insert":"Matrix4x4"},{"insert":" have improved hardware acceleration on .NET 8. For example, "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256-1"},"insert":"Vector256<T>"},{"insert":" was reimplemented to internally be "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"2x Vector128<T>"},{"insert":" operations, where possible. This allows partial acceleration of some functions when "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Vector128.IsHardwareAccelerated == true"},{"insert":" but "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Vector256.IsHardwareAccelerated == false"},{"insert":", such as on Arm64."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Hardware intrinsics are now annotated with the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"ConstExpected"},{"insert":" attribute. This ensures that users are aware when the underlying hardware expects a constant and therefore when a non-constant value may unexpectedly hurt performance."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"The "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.numerics.ifloatingpointieee754-1.lerp#system-numerics-ifloatingpointieee754-1-lerp(-0-0-0)"},"insert":"Lerp(TSelf, TSelf, TSelf)"},{"insert":" "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Lerp"},{"insert":" API has been added to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.numerics.ifloatingpointieee754-1"},"insert":"IFloatingPointIeee754<TSelf>"},{"insert":" and therefore to "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"float"},{"insert":" ("},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.single"},"insert":"Single"},{"insert":"), "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"double"},{"insert":" ("},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.double"},"insert":"Double"},{"insert":"), and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.half"},"insert":"Half"},{"insert":". This API allows a linear interpolation between two values to be performed efficiently and correctly."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Vector512 and AVX-512"},{"attributes":{"header":4},"insert":"\n"},{"insert":"\n.NET Core 3.0 expanded SIMD support to include the platform-specific hardware intrinsics APIs for x86/x64. .NET 5 added support for Arm64 and .NET 7 added the cross-platform hardware intrinsics. .NET 8 furthers SIMD support by introducing "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector512-1"},"insert":"Vector512<T>"},{"insert":" and support for "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-avx-512-instructions.html"},"insert":"Intel Advanced Vector Extensions 512 (AVX-512)"},{"insert":" instructions.\nSpecifically, .NET 8 includes support for the following key features of AVX-512:\n512-bit vector operations"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Additional 16 SIMD registers"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Additional instructions available for 128-bit, 256-bit, and 512-bit vectors"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"If you have hardware that supports the functionality, then "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector512.ishardwareaccelerated#system-runtime-intrinsics-vector512-ishardwareaccelerated"},"insert":"Vector512.IsHardwareAccelerated"},{"insert":" now reports "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"true"},{"insert":".\n.NET 8 also adds several platform-specific classes under the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86"},"insert":"System.Runtime.Intrinsics.X86"},{"insert":" namespace:\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512f"},"insert":"Avx512F"},{"insert":" (foundational)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512bw"},"insert":"Avx512BW"},{"insert":" (byte and word)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512cd"},"insert":"Avx512CD"},{"insert":" (conflict detection)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512dq"},"insert":"Avx512DQ"},{"insert":" (doubleword and quadword)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512vbmi"},"insert":"Avx512Vbmi"},{"insert":" (vector byte manipulation instructions)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"These classes follow the same general shape as other instruction set architectures (ISAs) in that they expose an "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512f.issupported#system-runtime-intrinsics-x86-avx512f-issupported"},"insert":"IsSupported"},{"insert":" property and a nested "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512f.x64"},"insert":"Avx512F.X64"},{"insert":" class for instructions available only to 64-bit processes. Additionally, each class has a nested "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx512f.vl"},"insert":"Avx512F.VL"},{"insert":" class that exposes the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Avx512VL"},{"insert":" (vector length) extensions for the corresponding instruction set.\nEven if you don't explicitly use "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Vector512"},{"insert":"-specific or "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"Avx512F"},{"insert":"-specific instructions in your code, you'll likely still benefit from the new AVX-512 support. The JIT can take advantage of the additional registers and instructions implicitly when using "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector128-1"},"insert":"Vector128<T>"},{"insert":" or "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256-1"},"insert":"Vector256<T>"},{"insert":". The base class library uses these hardware intrinsics internally in most operations exposed by "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.span-1"},"insert":"Span<T>"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.readonlyspan-1"},"insert":"ReadOnlySpan<T>"},{"insert":" and in many of the math APIs exposed for the primitive types.\nData validation"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nThe "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations"},"insert":"System.ComponentModel.DataAnnotations"},{"insert":" namespace includes new data validation attributes intended for validation scenarios in cloud-native services. While the pre-existing "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"DataAnnotations"},{"insert":" validators are geared towards typical UI data-entry validation, such as fields on a form, the new attributes are designed to validate non-user-entry data, such as "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/core/extensions/options#options-validation"},"insert":"configuration options"},{"insert":". In addition to the new attributes, new properties were added to the "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.rangeattribute"},"insert":"RangeAttribute"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.requiredattribute"},"insert":"RequiredAttribute"},{"insert":" types.\nNew APIDescription"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.rangeattribute.minimumisexclusive#system-componentmodel-dataannotations-rangeattribute-minimumisexclusive"},"insert":"RangeAttribute.MinimumIsExclusive"},{"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.rangeattribute.maximumisexclusive#system-componentmodel-dataannotations-rangeattribute-maximumisexclusive"},"insert":"RangeAttribute.MaximumIsExclusive"},{"insert":"Specifies whether bounds are included in the allowable range."},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.lengthattribute"},"insert":"System.ComponentModel.DataAnnotations.LengthAttribute"},{"insert":"Specifies both lower and upper bounds for strings or collections. For example, "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"[Length(10, 20)]"},{"insert":" requires at least 10 elements and at most 20 elements in a collection."},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.base64stringattribute"},"insert":"System.ComponentModel.DataAnnotations.Base64StringAttribute"},{"insert":"Validates that a string is a valid Base64 representation."},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.allowedvaluesattribute"},"insert":"System.ComponentModel.DataAnnotations.AllowedValuesAttribute"},{"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.deniedvaluesattribute"},"insert":"System.ComponentModel.DataAnnotations.DeniedValuesAttribute"},{"insert":"Specify allow lists and deny lists, respectively. For example, "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"[AllowedValues(\"apple\", \"banana\", \"mango\")]"},{"insert":".\nMetrics"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\nNew APIs let you attach key-value pair tags to "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter"},"insert":"Meter"},{"insert":" and "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.instrument"},"insert":"Instrument"},{"insert":" objects when you create them. Aggregators of published metric measurements can use the tags to differentiate the aggregated values.\nC#\nCopy\nMeterOptions options = new MeterOptions(\"name\")"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Version = \"version\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // Attach these tags to the created meter"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Tags = new TagList() { { \"MeterKey1\", \"MeterValue1\" }, { \"MeterKey2\", \"MeterValue2\" } }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"Meter meter = meterFactory.Create(options);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"Instrument instrument = meter.CreateCounter<int>(\"counter\", null, null, new TagList() { { \"counterKey1\", \"counterValue1\" } });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"instrument.Add(1);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"The new APIs include:\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meteroptions"},"insert":"MeterOptions"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter.-ctor#system-diagnostics-metrics-meter-ctor(system-diagnostics-metrics-meteroptions)"},"insert":"Meter(MeterOptions)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter.createcounter#system-diagnostics-metrics-meter-createcounter-1(system-string-system-string-system-string-system-collections-generic-ienumerable((system-collections-generic-keyvaluepair((system-string-system-object)))))"},"insert":"CreateCounter<T>(String, String, String, IEnumerable<KeyValuePair<String,Object>>)"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Cryptography"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n.NET 8 adds support for the SHA-3 hashing primitives. (SHA-3 is currently supported by Linux with OpenSSL 1.1.1 or later and Windows 11 Build 25324 or later.) APIs where SHA-2 is available now offer a SHA-3 compliment. This includes "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SHA3_256"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SHA3_384"},{"insert":", and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SHA3_512"},{"insert":" for hashing; "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HMACSHA3_256"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HMACSHA3_384"},{"insert":", and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HMACSHA3_512"},{"insert":" for HMAC; "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HashAlgorithmName.SHA3_256"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HashAlgorithmName.SHA3_384"},{"insert":", and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"HashAlgorithmName.SHA3_512"},{"insert":" for hashing where the algorithm is configurable; and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"RSAEncryptionPadding.OaepSHA3_256"},{"insert":", "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"RSAEncryptionPadding.OaepSHA3_384"},{"insert":", and "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"RSAEncryptionPadding.OaepSHA3_512"},{"insert":" for RSA OAEP encryption.\nThe following example shows how to use the APIs, including the "},{"attributes":{"background":"var(--theme-inline-code)","code":true},"insert":"SHA3_256.IsSupported"},{"insert":" property to determine if the platform supports SHA-3.\nC#\nCopy\n// Hashing example"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (SHA3_256.IsSupported)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    byte[] hash = SHA3_256.HashData(dataToHash);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"else"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"// Signing example"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (SHA3_256.IsSupported)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"     using ECDsa ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"     byte[] signature = ec.SignData(dataToBeSigned, HashAlgorithmName.SHA3_256);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"else"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"SHA-3 support is currently aimed at supporting cryptographic primitives. Higher-level constructions and protocols aren't expected to fully support SHA-3 initially. These protocols include X.509 certificates, "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.xml.signedxml"},"insert":"SignedXml"},{"insert":", and COSE.\nStream-based ZipFile methods"},{"attributes":{"header":3},"insert":"\n"},{"insert":"\n.NET 8 includes new overloads of "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.zipfile.createfromdirectory"},"insert":"ZipFile.CreateFromDirectory"},{"insert":" that allow you to collect all the files included in a directory and zip them, then store the resulting zip file into the provided stream. Similarly, new "},{"attributes":{"background":"rgba(0, 0, 0, 0)","color":"var(--theme-hyperlink)","link":"https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.zipfile.extracttodirectory"},"insert":"ZipFile.ExtractToDirectory"},{"insert":" overloads let you provide a stream containing a zipped file and extract its contents into the filesystem. These are the new overloads:\nC#\nCopy\nnamespace System.IO.Compression;"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"public static partial class ZipFile"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding? entryNameEncoding);"},{"attributes":{"code-block":true},"insert":"\n\n"},{"insert":"    public static void ExtractToDirectory(Stream source, string destinationDirectoryName) { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles) { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding) { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding, bool overwriteFiles) { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"These new APIs can be useful when disk space is constrained, because they avoid having to use the disk as an intermediate step.\n\n"},{"attributes":{"header":2},"insert":"\n"}]}